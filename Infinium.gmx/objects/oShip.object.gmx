<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sShip</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-50</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Vars

//Create


//User Control
userControl = true;

//Center of screen
x = room_width/2;
y = room_height/2;

//Horizontal speed
hsp = 0;
//Vertical speed
vsp = 0;
//Both of the above are used to manually calculate the speed and are then added to GM's inbuilt variables to give the ship speed. 
//Thrust is used to gradually increase the amount of speed being given to the ship. 
thrust = 0;

//Shooting
//Max and min amount of variation
variationAmount = 8;
//Used to actually set the amount of variation
variation = 0;

//Timer is set to false initially, althought there is only 1 step inbetween each shot.
//To the player there is no delay between spawning and shooting. 
canShoot = false;
//Used to check, above is actual below is the check i.e. (canShootTimer &gt;= fireDelayTimer)
canShootTimer = 0;
fireDelayTime = 1;

//Warp 
//Initial count, have to maintain speed for x amount of time before warp
warpSpeedCount = 0;
//Player is given a warning for how long until warp goes 
warpSpeedCountdown = 0;
//Draw warning or no
drawCountdown = false;
//Debugging
stage = 0;
//Seconds for countdown
countdown = 5;





</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Zoom Vars

baseWidth = view_wview[0];
baseHeight = view_hview[0];
zoomLevel = 100;
zoomType = "none";
zoomPerStep = 0;
zoomChange = 0.05;
zoomFactor = 1;
maxZoom = 80;
minZoom = 2000;

s = 1;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Movement

if(userControl == true){


//use script found online to smoothly rotate the ship towards the mouse, at the speed set at the end.
image_angle = smooth_rotate(image_angle, point_direction(x,y,mouse_x,mouse_y), 14);
//Direction is = to the image angle
dir = image_angle;

//If pressing space -&gt; Move
if(keyboard_check(vk_space)){
    //Sets a max amount to the hsp and vsp, with 0.8 =&gt; ~25.
    hsp *= 0.80;
    vsp *= 0.80;
    
    //Thrust amount is based on distance to mouse, higher the /x is the slower the ships gets up to max speed. 
    thrust += distance_to_point(mouse_x,mouse_y)/10000;
    //Thrust is also capped at a set amount of 5. 
    if(thrust &gt; 5){
        thrust = 5;
    }
    
    //Hsp and Vsp are set to += the lengthdir of thrust and dir. 
    hsp += lengthdir_x(thrust,dir);
    vsp += lengthdir_y(thrust,dir);
    
} else{
    //If not thrusting, thrust will eventually be set to zero.
    thrust *= 0.95;
    /**

        This is where the current issue with controls is.
        
        The ship can be going in the same direction as before, but because the user has let go of the spacebar,
        thrust is still decreasing. 
        
        So if the payer hits space going in the same direction, they might actually slow themselves down. Depending 
        on the amount of time taken.     
    
    **/
    
    
}

//Put the manually variables to use, using the built in variables. 
hspeed = hsp;
vspeed = vsp;

if(speed == 25 &amp;&amp; keyboard_check(vk_space)){
    stage=1;
    if(warpSpeedCount&lt;=150){
        warpSpeedCount++;
    } else{
        stage=2;
        if(warpSpeedCountdown&lt;=150){
            stage = 2.5;
            warpSpeedCountdown++;
            if(warpSpeedCountdown%30 = 0){
                countdown--;
            }
            drawCountdown = true;
        }else if(warpSpeedCountdown &gt;= 160){
            stage=3;
            warpSpeed();
        }
    }
} else{
stage=0;
    warpSpeedCount = 0;
    warpSpeedCountdown = 0;
    drawCountdown = false;
}


//Temporary key to set speed to 0.
if(keyboard_check(ord('S'))){
    speed = 0;
}

//Parallaxing Stars
tile_layer_shift(-12,hsp*0.25,vsp*0.25);
tile_layer_shift(-11,hsp*0.125,vsp*0.125);
tile_layer_shift(-10,hsp*0.06125,vsp*0.06125);

} else{
    if(distance_to_point(desX,desY) &lt; 25){
        move_towards_point(desX,desY,2.5);
    } else{
        speed = 0;
        room_goto(rPlanet);
    }
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Zoom
if(userControl == true){
//Center of screen(view) is set and stored in this vars.
var viewCenterX, viewCenterY;
viewCenterX = view_xview[0] + view_wview[0] / 2;
viewCenterY = view_yview[0] + view_hview[0] / 2;

//Change based on what direction the user is scrolling
switch(zoomType){
    //Scrolling up, zooms "in"
    case "in":
        //Maths, to get the amount of zoom per step.
        zoomLevel = min(zoomLevel + (zoomFactor * zoomPerStep), minZoom);
        break;
    //Scrolling down, zooms "out".
    case "out":
        //Maths, to get the amount of zoom per step.
        zoomLevel = max(zoomLevel - (zoomFactor * zoomPerStep), maxZoom);
        break;
}

//Actually seting the zoom to be what was calculated above.
view_wview[0] = baseWidth *(zoomLevel / 100);
view_hview[0] = baseHeight *(zoomLevel / 100);
//Recentering screen
view_xview[0] = viewCenterX - view_wview[0] / 2;
view_yview[0] = viewCenterY - view_hview[0] / 2;

if(zoomPerStep &gt; 0){
    zoomPerStep -= zoomChange;
} else{
    zoomType = "none";
}

//Have to manually set the view or the player is stuck in the room.
view_hborder[0] = 1280;
view_vborder[0] = 720;
view_xview[0]=x-(view_wview[0]/2);
view_yview[0]=y-(view_hview[0]/2);


if(mouse_wheel_up()){
    //Mouse wheel up = out
    zoomType = "out";
    //ZPS
    zoomPerStep = 2.5;
}

if(mouse_wheel_down()){
    //Mouse Wheel down = "in"
    zoomType = "in";
    //ZPS
    zoomPerStep = 2.5;
}

if(keyboard_check(vk_lalt)){
    //Mouse Wheel down = "in"
    s+=0.1;
    zoomLevel += s;
} else if(keyboard_check(vk_ralt)){
    //Mouse Wheel down = "in"
    s+=0.1;
    if(zoomLevel &gt; 80){
        zoomLevel -= s;
    }
} else{
    s = 1;
}

}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Left Click

//Fire

if(userControl == true){
//If cant shoow
if(!canShoot){
    //and timer is still not where it needs to be
    if(canShootTimer &lt;= fireDelayTime){
        //increase the timer by 1.
        canShootTimer++;
    } else{
        //Otherwise, the player can shoot. 
        canShoot = true;
    }
}

//If player hits left mouse button, and they can fire
if(mouse_check_button(mb_left) &amp;&amp; canShoot &amp;&amp; !place_meeting(mouse_x,mouse_y,oHoverable)){
    //Create a bullet at this position
    arr = instance_create(x,y,oLaser);
    //Set variation to be inbetween the max and min of set variationAmount
    variation = random_range(-variationAmount,variationAmount);
    //Direction is equal to that of the mouse, +- the variation set above
    arr.direction = point_direction(x,y,mouse_x,mouse_y) + variation;
    //Image angle is equal to direction
    arr.image_angle = arr.direction;
    //Speed is equal to ships speed + 15
    arr.speed = speed+15;
    //Set timer for user to shoot back to 0
    canShootTimer = 0;
    //And set canShoot to false
    canShoot = false;
}

//Select Planet

if(mouse_check_button(mb_left) &amp;&amp; place_meeting(mouse_x,mouse_y,oHoverable)){
    p = instance_place(mouse_x,mouse_y,oPlanet);
    gotoPlanet(instance_place(mouse_x,mouse_y,oPlanet));
    oShip.userControl = false; 
    with(oShip){
        desX = p.x;
        desY = p.y;
    }
}


}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Upgrade Screen
if(userControl == true){
//Key to go to the upgrade screen. 
if(keyboard_check_released(ord('E'))){
    room_goto(rUpgrade);
}   
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Optimization
instance_activate_all();
instance_deactivate_region(view_xview[0] - 64, view_yview - 64, view_wview[0] + 128, view_hview + 128, false, false);

if(zoomLevel &gt;= 500){
    showMeteor(false);
    showStars(false,-12);
} else if(zoomLevel &lt; 500){
    showMeteor(true);
    showStars(true,-12);
}

if(zoomLevel &gt;= 750){
    showStars(false,-11);
} else if(zoomLevel &lt; 750){
    showStars(true,-11);
}

if(zoomLevel &gt;= 1000){
    showStars(false,-10);
    showGalaxy(true);
} else if(zoomLevel &lt; 1000){
    showStars(true,-10);
    showGalaxy(false);
}



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="oMeteor">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Collision Event

//With the meteor
with(other){
    //Do this 3 times
    repeat(3){
        //Create object of chunk, with name of C.
        c = instance_create(x,y,oChunk);
        //Direction of chunk is set to random range.
        c.direction = random_range(oShip.direction-35,oShip.direction+35);
        //Speed is inbetween of the below random range.
        c.speed = random_range(3,9);
    }
    //Meteors alarm event is set to 15.
    alarm[0] = 15;
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///GUI
//global.length is set in the mouse object.
//Returns length to center of screen
l = global.length/250;
//pointdirection gives the angle from mouse and center of screen
d = point_direction(view_wview[0]/2,view_hview[0]/2,mouse_x,mouse_y);





//Used to add/subtract from gui's base position
xChange = lengthdir_x(l,d);
yChange = lengthdir_y(l,d);

       if(mouse_x &gt;= view_xview[0]+view_wview[0]/2 &amp;&amp; mouse_y &lt;= view_yview[0]+view_hview[0]/2){
            yChange *= -1;
} else if(mouse_x &lt; view_xview[0]+view_wview[0]/2 &amp;&amp; mouse_y &lt;= view_yview[0]+view_hview[0]/2){
            xChange *= -1;
            yChange *= -1;
} else if(mouse_x &gt;= view_xview[0]+view_wview[0]/2 &amp;&amp; mouse_y &gt; view_yview[0]+view_hview[0]/2){
            //nothing
} else if(mouse_x &lt; view_xview[0]+view_wview[0]/2 &amp;&amp; mouse_y &gt; view_yview[0]+view_hview[0]/2){
            xChange *= -1;
}

//Set GUI size
display_set_gui_size(1280,720);

//Font is set to console
draw_set_font(faConsole);
//Color of text is white
draw_set_colour(c_white);
//Halighn is set to left
draw_set_halign(fa_left);

//Text
draw_text(5 + xChange,  2 + yChange, "Delta: "        + string(fps_real));
draw_text(5 + xChange, 16 + yChange, "FPS: "          + string(fps));
draw_text(5 + xChange, 30 + yChange, "Speed: "        + string(speed));
draw_text(5 + xChange, 44 + yChange, "xChange: "      + string(xChange));
draw_text(5 + xChange, 60 + yChange, "yChange: "      + string(yChange));
draw_text(5 + xChange, 74 + yChange, "Stage: "        + string(stage));
draw_text(5 + xChange, 88 + yChange, "InstCount: "    + string(instance_count));
draw_text(5 + xChange, 102+ yChange, "ZoomLevel: "    + string(zoomLevel));

//B = Electric Blue
b = $A9A209;
//G = Electric Green
g = $54A909;

//Set alpha to 0.75 for effect
draw_set_alpha(0.75);
//Draw the boostbar spreite at set location
draw_sprite(sBB,0,10 + xChange,710 + yChange);
//Draw hbar with total of speed.
draw_healthbar(13 + xChange,710 + yChange,341 + xChange,660 + yChange,speed*4,c_white,g,b,0,false,false);
//Reset alpha
draw_set_alpha(1);



if(drawCountdown = true){
    draw_set_halign(fa_center);
    draw_text(display_get_gui_width()/2,(display_get_gui_height()/2) - 75, "Countdown...");
    draw_text(display_get_gui_width()/2,(display_get_gui_height()/2) - 60, countdown);
}





</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw

//Set alpha to 0.75 for effect
draw_set_alpha(0.75);
//Actually draw the trail, with script
draw_trail(32,4,c_gray,-1,true,1);
//Reset alpha to 1.
draw_set_alpha(1);


//Draw Line to newarest planet
if(instance_exists(oPlanet)){
p = instance_nearest(x,y,oPlanet);
draw_set_color(p.image_blend);
draw_line(x,y,p.x,p.y,);
}
//Draw the ship above the trail
draw_self();

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
